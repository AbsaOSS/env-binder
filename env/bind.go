/*
Copyright 2021 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

package env

import (
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"unsafe"
)

type field struct {
	env        env
	fieldName  string
	fieldType  *reflect.Type
	fieldValue *reflect.Value
	public     bool
}

// contains raw info about string tag field. e.g: default=hello,
type strTag struct {
	value  string
	exists bool
}

type env struct {
	value     string
	name      string
	tagName   string
	def       strTag
	req       strTag
	protected strTag
	present   bool
}

type meta map[string]field

// Bind binds environment variables into structure
func Bind(s interface{}) (err error) {
	var meta meta
	if s == nil {
		return fmt.Errorf("invalid argument value (nil)")
	}
	v := reflect.ValueOf(s)
	t := reflect.TypeOf(s).Kind()
	if t != reflect.Ptr {
		return fmt.Errorf("argument must be pointer to structure")
	}
	if v.Elem().Kind() != reflect.Struct {
		return fmt.Errorf("argument must be pointer to structure")
	}
	meta, err = roll(v.Elem(), v.Elem().Type().Name(), "")
	if err != nil {
		return
	}
	err = bind(meta)
	return
}

// binds meta to structure pointer
func bind(m meta) (err error) {
	for k, v := range m {
		f := reflect.NewAt(v.fieldValue.Type(), unsafe.Pointer(v.fieldValue.UnsafeAddr())).Elem()
		switch f.Interface().(type) {
		case bool:
			var b bool
			if v.env.protected.isTrue() {
				continue
			}
			b, err = boolean(v.env)
			if err != nil {
				return
			}
			f.SetBool(b)
			continue

		case int, int8, int16, int32, int64:
			if v.env.protected.isTrue() && v.fieldValue.Int() != 0 {
				continue
			}
			err = setNumeric(f, v)
			if err != nil {
				return
			}
			continue

		case float32, float64:
			if v.env.protected.isTrue() && v.fieldValue.Float() != 0 {
				continue
			}
			err = setNumeric(f, v)
			if err != nil {
				return
			}
			continue

		case uint, uint8, uint16, uint32, uint64:
			if v.env.protected.isTrue() && v.fieldValue.Uint() != 0 {
				continue
			}
			err = setNumeric(f, v)
			if err != nil {
				return
			}
			continue

		case string:
			var s string
			if v.env.protected.isTrue() && v.fieldValue.String() != "" {
				continue
			}
			s = GetEnvAsStringOrFallback(v.env.name, v.env.def.value)
			f.SetString(s)
			continue

		case []string:
			if v.env.protected.isTrue() && !v.fieldValue.IsNil() {
				continue
			}
			var ss []string
			ss = GetEnvAsArrayOfStringsOrFallback(v.env.name, v.env.def.asStringSlice())
			f.Set(reflect.ValueOf(ss))
			continue

		case []int, []int8, []int16, []int32, []int64, []float32, []float64, []uint, []uint8, []uint16, []uint32, []uint64:
			if v.env.protected.isTrue() && !v.fieldValue.IsNil() {
				continue
			}
			var floats []float64
			floats, err = floatSlice(v.env)
			if err != nil {
				return
			}
			setNumericSlice(f, floats)
			continue

		case []bool:
			if v.env.protected.isTrue() && !v.fieldValue.IsNil() {
				continue
			}
			var bs []bool
			bs, err = boolSlice(v.env)
			if err != nil {
				return
			}
			f.Set(reflect.ValueOf(bs))
			continue

		default:
			err = fmt.Errorf("unsupported type %s: %s", k, v.fieldValue.Type().Name())
		}
	}
	return err
}

func setNumericSlice(f reflect.Value, floats []float64) {
	switch f.Interface().(type) {
	case []uint:
		f.Set(reflect.ValueOf(convertToUInt(floats)))
		return
	case []uint8:
		f.Set(reflect.ValueOf(convertToUInt8(floats)))
		return
	case []uint16:
		f.Set(reflect.ValueOf(convertToUInt16(floats)))
		return
	case []uint32:
		f.Set(reflect.ValueOf(convertToUInt32(floats)))
		return
	case []uint64:
		f.Set(reflect.ValueOf(convertToUInt64(floats)))
		return
	case []int:
		f.Set(reflect.ValueOf(convertToInt(floats)))
		return
	case []int8:
		f.Set(reflect.ValueOf(convertToInt8(floats)))
		return
	case []int16:
		f.Set(reflect.ValueOf(convertToInt16(floats)))
		return
	case []int32:
		f.Set(reflect.ValueOf(convertToInt32(floats)))
		return
	case []int64:
		f.Set(reflect.ValueOf(convertToInt64(floats)))
		return
	case []float32:
		f.Set(reflect.ValueOf(convertToFloat32(floats)))
		return
	case []float64:
		f.Set(reflect.ValueOf(floats))
		return
	}
}

func setNumeric(f reflect.Value, v field) (err error) {
	var fl float64
	fl, err = float(v.env)
	if err != nil {
		return
	}
	switch f.Interface().(type) {
	case int, int8, int16, int32, int64:
		f.SetInt(int64(fl))
		return
	case float32, float64:
		f.SetFloat(fl)
		return
	case uint, uint8, uint16, uint32, uint64:
		f.SetUint(uint64(fl))
		return
	}
	return
}

// recoursive function builds meta structure
func roll(value reflect.Value, n, prefix string) (m meta, err error) {
	const tagEnv = "env"

	m = meta{}
	for i := 0; i < value.NumField(); i++ {
		var e env
		vf := value.Field(i)
		tf := value.Type().Field(i)
		key := fmt.Sprintf("%s.%s", n, tf.Name)
		tag := tf.Tag.Get(tagEnv)
		if vf.Kind() == reflect.Struct {
			var sm meta
			prefix := strings.TrimPrefix(fmt.Sprintf("%s_%s", prefix, getTagName(tag)), "_")
			sm, err = roll(vf, key, prefix)
			if err != nil {
				return
			}
			for k, v := range sm {
				m[k] = v
			}
			continue
		}
		if tag == "" {
			continue
		}
		if e, err = parseTag(tag, prefix); err != nil {
			return
		}
		if !e.present && e.req.value == "true" {
			err = fmt.Errorf("%s is required", e.name)
			return
		}
		m[key] = field{
			env:        e,
			fieldName:  tf.Name,
			fieldType:  &tf.Type,
			fieldValue: &vf,
			public:     tf.PkgPath == "",
		}
	}
	return m, err
}

// parseTag, retrieves env info and metadata
func parseTag(tag, prefix string) (e env, err error) {
	var def, req, protected strTag
	var tagName = getTagName(tag)
	req, err = getTagProperty(tag, "require")
	if err != nil {
		return
	}
	def, err = getTagProperty(tag, "default")
	if err != nil {
		return
	}
	protected, err = getTagProperty(tag, "protected")
	if err != nil {
		return
	}
	envName := getEnvName(tagName, prefix)
	value, exists := os.LookupEnv(envName)
	e = env{
		name:      envName,
		tagName:   tagName,
		value:     value,
		req:       req,
		def:       def,
		protected: protected,
		present:   exists,
	}
	return
}

func getEnvName(envName, prefix string) string {
	if prefix != "" {
		return fmt.Sprintf("%s_%s", prefix, envName)
	}
	return envName
}

func getTagName(tag string) string {
	return regexp.MustCompile("[a-zA-Z_]+[a-zA-Z0-9_]*").FindString(tag)
}

// parses value from env tag and returns <tag value, tag value exists, error>
func getTagProperty(tag, t string) (r strTag, err error) {
	const arr = `\[\w*\s*\!*\@*\#*\$*\%*\^*\&*\**\(*\)*\_*\-*\+*\<*\>*\?*\~*\=*\,*\.*\/*\{*\}*\|*\;*\:*\/*\'*\"*\/*\\*`
	const scalar = `\[*\]*\w*\s*\!*\@*\#*\$*\%*\^*\&*\**\(*\)*\_*\-*\+*\<*\>*\?*\~*\=*\.*\/*\{*\}*\|*\;*\:*\/*\'*\"*\/*\\*`
	r = strTag{}
	var findRegex, removeRegex *regexp.Regexp
	//	findRegex, err = regexp.Compile(",\\s*" + t + "\\s*=((\\s*([\\[\\w*\\,*\\.*\\s*\\-*])*\\])|(\\s*\\w*\\.*\\-*)*)")
	findRegex, err = regexp.Compile(",\\s*" + t + "\\s*=((\\s*\\[[" + arr + "]*\\])|(" + scalar + ")*)")
	if err != nil {
		err = fmt.Errorf("ivalid %s", t)
		return
	}
	removeRegex, err = regexp.Compile(",\\s*" + t + "\\s*=\\s*")
	if err != nil {
		err = fmt.Errorf("ivalid %s", t)
		return
	}
	match := findRegex.FindString(tag)
	if match == "" {
		return
	}
	remove := removeRegex.FindString(strings.ToLower(tag))
	r.value = strings.ReplaceAll(match, remove, "")
	r.exists = true
	return
}

func (t strTag) asStringSlice() (s []string) {
	if !t.exists {
		return
	}
	envdef := strings.TrimSuffix(strings.TrimPrefix(t.value, " "), " ")
	envdef = strings.TrimSuffix(strings.TrimPrefix(envdef, "["), "]")
	s = strings.Split(envdef, ",")
	if s[0] == "" {
		s = []string{}
	}
	return
}

func (t strTag) isTrue() bool {
	if !t.exists {
		return false
	}
	b, _ := strconv.ParseBool(t.value)
	return b
}
